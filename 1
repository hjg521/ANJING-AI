# src/core/screenshot.py
# 2025ç»ˆææˆªå›¾ç®¡ç†å™¨ï¼ˆDXGIå¤šçº¿ç¨‹ + DXGIå•çº¿ç¨‹ + å¥æŸ„ + MSSï¼Œå››ç§æ¨¡å¼UIåˆ‡æ¢ï¼‰

import numpy as np
import cv2
import mss
import threading
import time
import win32gui
import win32ui
import win32con
import win32api

class ScreenshotManager:
    """
    ç»Ÿä¸€æˆªå›¾ç®¡ç†å™¨
    mode: "dxgi_thread" (é»˜è®¤æ¨è) / "dxgi" / "handle" / "mss"
    """
    def __init__(self, mode="dxgi_thread", window_title=None):
        self.mode = mode.lower()
        self.window_title = window_title
        self.hwnd = self._find_window_hwnd()

        self.running = False
        self.latest_frame = None
        self.lock = threading.Lock()

        self.sct = mss.mss() if "mss" in self.mode else None
        self.monitor = None

        if "mss" in self.mode or self.mode == "handle":
            self._setup_fallback()

    def _find_window_hwnd(self):
        if not self.window_title:
            return None
        hwnds = []
        def enum_handler(hwnd, ctx):
            if win32gui.IsWindowVisible(hwnd) and self.window_title in win32gui.GetWindowText(hwnd):
                ctx.append(hwnd)
        win32gui.EnumWindows(enum_handler, hwnds)
        return hwnds[0] if hwnds else None

    def _setup_fallback(self):
        if self.hwnd:
            try:
                rect = win32gui.GetClientRect(self.hwnd)
                pos = win32gui.ClientToScreen(self.hwnd, (0, 0))
                self.monitor = {"top": pos[1], "left": pos[0], "width": rect[2], "height": rect[3]}
            except:
                self.monitor = self.sct.monitors[1]
        else:
            self.monitor = self.sct.monitors[1]

    def capture(self):
        """å•æ¬¡æˆªå›¾ï¼ˆç”¨äºå•çº¿ç¨‹æ¨¡å¼ï¼‰"""
        if self.mode == "dxgi_thread":
            # å¤šçº¿ç¨‹æ¨¡å¼ä¸‹ï¼Œç”¨æœ€æ–°å¸§
            return self.get_latest_frame()
        elif self.mode == "dxgi":
            return self._capture_dxcam()
        elif self.mode == "handle":
            return self._capture_handle()
        elif self.mode == "mss":
            return self._capture_mss()
        return None

    def _capture_dxcam(self):
        """DXGI å•çº¿ç¨‹ï¼ˆç”¨ dxcamï¼Œå…è´¹ã€é«˜æ€§èƒ½ï¼‰"""
        try:
            import dxcam
            camera = dxcam.create(output_idx=0, max_buffer_len=1)
            frame = camera.grab()
            return frame
        except:
            print("[DXGI] dxcamå¤±è´¥ï¼Œå›é€€MSS")
            return self._capture_mss()

    def _capture_handle(self):
        if not self.hwnd or not win32gui.IsWindow(self.hwnd):
            return None
        try:
            left, top, right, bot = win32gui.GetClientRect(self.hwnd)
            w, h = right - left, bot - top
            hwndDC = win32gui.GetWindowDC(self.hwnd)
            mfcDC = win32ui.CreateDCFromHandle(hwndDC)
            saveDC = mfcDC.CreateCompatibleDC()
            bitmap = win32ui.CreateBitmap()
            bitmap.CreateCompatibleBitmap(mfcDC, w, h)
            saveDC.SelectObject(bitmap)
            win32gui.BitBlt(saveDC.GetSafeHandle(), 0, 0, w, h, mfcDC.GetSafeHandle(), 0, 0, win32con.SRCCOPY)
            bmpinfo = bitmap.GetInfo()
            bmpstr = bitmap.GetBitmapBits(True)
            img = np.frombuffer(bmpstr, dtype='uint8').reshape((h, w, 4))
            img = img[..., :3][..., ::-1]  # BGRA -> BGR
            # æ¸…ç†
            win32gui.DeleteObject(bitmap.GetHandle())
            saveDC.DeleteDC()
            mfcDC.DeleteDC()
            win32gui.ReleaseDC(self.hwnd, hwndDC)
            return img
        except:
            return None

    def _capture_mss(self):
        try:
            sct_img = self.sct.grab(self.monitor or self.sct.monitors[1])
            img = np.array(sct_img)
            return cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
        except:
            return None

    def start_continuous(self, callback):
        """å¯åŠ¨å¤šçº¿ç¨‹æŒç»­æˆªå›¾ï¼ˆä»… dxgi_thread æ¨¡å¼ï¼‰"""
        if self.mode != "dxgi_thread":
            return

        def loop():
            try:
                import dxcam
                camera = dxcam.create(output_idx=0, max_buffer_len=1)
                while self.running:
                    frame = camera.grab()
                    if frame is not None:
                        with self.lock:
                            self.latest_frame = frame
                        callback(frame)
                    time.sleep(0.008)  # ~125FPS
            except Exception as e:
                print(f"[DXGI Thread] å¼‚å¸¸: {e}, å›é€€å•æ¬¡æ•è·")
                while self.running:
                    frame = self._capture_mss()
                    if frame is not None:
                        callback(frame)
                    time.sleep(0.016)

        self.running = True
        threading.Thread(target=loop, daemon=True).start()

    def get_latest_frame(self):
        with self.lock:
            return self.latest_frame.copy() if self.latest_frame is not None else None

    def stop(self):
        self.running = False

# ============ å…¨å±€å®ä¾‹ï¼ˆé»˜è®¤ DXGI å¤šçº¿ç¨‹ï¼‰ ============
game_capture = ScreenshotManager(mode="dxgi_thread")# src/core/yolo_ai.py
# 2025å¹´æœ€å¼ºYOLOè§†è§‰æ ¸å¿ƒï¼ˆultralytics + TensorRTåºåˆ—åŒ–å¼•æ“åŠ é€Ÿ + poseéª¨éª¼ä¸€ä½“ï¼‰

import os
import threading
import torch
import numpy as np
from ultralytics import YOLO

from src.tools.resource_path import resource_path
from src.config.models import GAME_SPECIFIC_MODELS, DEFAULT_MODEL

class YOLOModelManager:
    """
    YOLOæ¨¡å‹ç®¡ç†å™¨ï¼ˆTensorRTç»ˆæåŠ é€Ÿç‰ˆï¼‰
    - ä¼˜å…ˆåŠ è½½ .engine åºåˆ—åŒ–å¼•æ“ï¼ˆç§’å¼€ï¼‰
    - æœªæ‰¾åˆ°åˆ™è‡ªåŠ¨æ„å»ºï¼ˆé¦–æ¬¡æ…¢ï¼Œåç»­æå¿«ï¼‰
    - æ”¯æŒæ¸¸æˆä¸“ç”¨æ¨¡å‹ç‹¬ç«‹å¼•æ“
    - CUDAåŠç²¾åº¦ + åŠ¨æ€è¾“å…¥
    """
    def __init__(self):
        self.current_game = None
        self.current_model_name = None
        self.model = None
        self.device = "cuda" if torch.cuda.is_available() else "cpu"
        self.model_lock = threading.Lock()

        print(f"[YOLO] ä½¿ç”¨è®¾å¤‡: {self.device}")
        self.load_default_model()

    def _get_engine_path(self, model_filename: str):
        """ç”Ÿæˆå¯¹åº”çš„ .engine æ–‡ä»¶è·¯å¾„ï¼ˆæ”¾åœ¨ models/engines/ï¼‰"""
        engine_dir = resource_path("models/engines")
        os.makedirs(engine_dir, exist_ok=True)
        base_name = os.path.splitext(model_filename)[0]
        return os.path.join(engine_dir, f"{base_name}.engine")

    def _build_and_save_engine(self, pt_path: str, engine_path: str):
        """é¦–æ¬¡æ„å»ºTensorRTå¼•æ“å¹¶åºåˆ—åŒ–ä¿å­˜"""
        print(f"[YOLO] é¦–æ¬¡æ„å»ºTensorRTå¼•æ“ï¼ˆå¯èƒ½éœ€1-5åˆ†é’Ÿï¼Œè¯·è€å¿ƒç­‰å¾…ï¼‰...")
        try:
            temp_model = YOLO(pt_path)
            temp_model.export(
                format="engine",
                imgsz=640,
                half=True,           # FP16
                dynamic=True,        # æ”¯æŒåŠ¨æ€è¾“å…¥å°ºå¯¸
                workspace=8,         # GB
                verbose=False
            )
            print(f"[YOLO] TensorRTå¼•æ“æ„å»ºå®Œæˆ: {engine_path}")
        except Exception as e:
            print(f"[YOLO] å¼•æ“æ„å»ºå¤±è´¥: {e}ï¼Œå›é€€åŸå§‹æ¨¡å‹")

    def _load_model_with_trt(self, model_filename: str):
        """ä¼˜å…ˆåŠ è½½ .engineï¼Œå¦åˆ™æ„å»ºååŠ è½½"""
        pt_path = resource_path(os.path.join("models", model_filename))
        engine_path = self._get_engine_path(model_filename)

        if os.path.exists(engine_path):
            print(f"[YOLO] åŠ è½½åºåˆ—åŒ–TensorRTå¼•æ“: {os.path.basename(engine_path)}")
            with self.model_lock:
                self.model = YOLO(engine_path)
        elif os.path.exists(pt_path):
            # æ„å»ºå¼•æ“
            self._build_and_save_engine(pt_path, engine_path)
            if os.path.exists(engine_path):
                with self.model_lock:
                    self.model = YOLO(engine_path)
            else:
                # å›é€€åŸå§‹
                print(f"[YOLO] å›é€€åŠ è½½åŸå§‹PTæ¨¡å‹: {model_filename}")
                with self.model_lock:
                    self.model = YOLO(pt_path)
                    if self.device == "cuda":
                        self.model.model.half()
        else:
            print(f"[YOLO] æ¨¡å‹æ–‡ä»¶ä¸å­˜åœ¨: {model_filename}")
            self.model = None

        self.current_model_name = model_filename

    def load_default_model(self):
        self._load_model_with_trt(DEFAULT_MODEL)

    def switch_game_model(self, game_key: str):
        if game_key == self.current_game:
            return

        model_filename = GAME_SPECIFIC_MODELS.get(game_key.upper(), DEFAULT_MODEL)
        self._load_model_with_trt(model_filename)
        self.current_game = game_key

    def infer(self, image_np: np.ndarray, conf: float = 0.35, classes=None):
        if self.model is None:
            return []

        results = self.model(image_np, conf=conf, classes=classes, verbose=False)[0]

        output = []
        boxes = results.boxes
        keypoints = results.keypoints.xy.cpu().numpy() if results.keypoints is not None else None

        for i, box in enumerate(boxes):
            x1, y1, x2, y2 = box.xyxy[0].tolist()
            confidence = float(box.conf)
            class_id = int(box.cls)
            class_name = results.names[class_id]

            item = {
                "box": [float(x1), float(y1), float(x2), float(y2)],
                "conf": confidence,
                "cls": class_id,
                "name": class_name,
            }

            if keypoints is not None and i < len(keypoints):
                item["keypoints"] = keypoints[i].tolist()

            output.append(item)

        return output

    def async_infer(self, image_np: np.ndarray, callback, conf: float = 0.35, classes=None):
        def worker():
            try:
                results = self.infer(image_np, conf, classes)
                callback(results)
            except Exception as e:
                print(f"[YOLO] å¼‚æ­¥æ¨ç†å¼‚å¸¸: {e}")
                callback([])

        thread = threading.Thread(target=worker, daemon=True)
        thread.start()

# ============ å…¨å±€å•ä¾‹ ============
visual_core = YOLOModelManager()# src/devices/hardware.py
# 2025å¹´ç»ˆæç¡¬ä»¶ç›’å­å¯¹æ¥ç‰ˆï¼ˆæ”¯æŒKMBox NetçœŸå®åè®®ï¼‰

import threading
import socket
import time
import struct
import random

class HardwareDeviceManager:
    """
    ç¡¬ä»¶ç›’å­é€šä¿¡ç®¡ç†å™¨ï¼ˆæ”¯æŒKMBox Netç­‰UDPåè®®ç›’å­ï¼‰
    """
    def __init__(self):
        self.connected_devices = {}  # device_ip: {"sock": sock, "last_heartbeat": time}
        self.connection_lock = threading.Lock()
        self.heartbeat_thread = None
        self.running = False

        # é»˜è®¤KMBox Net IPå’Œç«¯å£ï¼ˆå¯æ”¹æˆä½ çš„ç›’å­IPï¼‰
        self.default_ip = "192.168.1.100"
        self.port = 12345

    def scan_devices(self):
        """è‡ªåŠ¨æ‰«æå¸¸è§KMBox IPï¼ˆå¯æ‰©å±•ï¼‰"""
        possible_ips = [f"192.168.1.{i}" for i in range(100, 200)]
        possible_ips.append(self.default_ip)

        found = []
        for ip in possible_ips:
            if self.connect_to_device(ip):
                found.append(ip)

        if found:
            print(f"[Hardware] æ‰«æå‘ç°è®¾å¤‡: {found}")
        else:
            print("[Hardware] æœªå‘ç°ç¡¬ä»¶ç›’å­ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼")

        return found

    def connect_to_device(self, device_ip):
        """è¿æ¥KMBox Net"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(2.0)

            # KMBox Netåˆå§‹åŒ–å‘½ä»¤ï¼ˆçœŸå®åè®®ï¼‰
            init_cmd = bytes.fromhex("01 00 00 00 00 00")
            sock.sendto(init_cmd, (device_ip, self.port))

            # æ¥æ”¶å“åº”
            data, addr = sock.recvfrom(1024)
            if data and addr[0] == device_ip:
                with self.connection_lock:
                    self.connected_devices[device_ip] = {
                        "sock": sock,
                        "last_heartbeat": time.time()
                    }
                print(f"[Hardware] æˆåŠŸè¿æ¥KMBox: {device_ip}")
                self.start_heartbeat()
                return True
        except Exception as e:
            # print(f"[Hardware] è¿æ¥ {device_ip} å¤±è´¥: {e}")
            pass
        return False

    def disconnect_device(self, device_ip):
        with self.connection_lock:
            if device_ip in self.connected_devices:
                try:
                    self.connected_devices[device_ip]["sock"].close()
                except:
                    pass
                del self.connected_devices[device_ip]
                print(f"[Hardware] æ–­å¼€ {device_ip}")

    def send_action(self, device_ip, action_data):
        """
        å‘é€é¼ æ ‡/é”®ç›˜æŒ‡ä»¤åˆ°ç›’å­
        action_data: {"type": "mouse_move", "dx": int, "dy": int}
                     {"type": "mouse_click", "button": "left"}
        """
        if device_ip not in self.connected_devices:
            print(f"[Hardware] {device_ip} æœªè¿æ¥ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼: {action_data}")
            time.sleep(0.002)
            return True

        sock = self.connected_devices[device_ip]["sock"]

        try:
            if action_data["type"] == "mouse_move":
                dx = action_data.get("dx", 0)
                dy = action_data.get("dy", 0)
                # KMBox Neté¼ æ ‡ç§»åŠ¨å‘½ä»¤ï¼ˆçœŸå®åè®®ï¼‰
                cmd = struct.pack("<Bhh", 0x02, dx, dy)  # 0x02 = é¼ æ ‡ç§»åŠ¨
                sock.sendto(cmd, (device_ip, self.port))

            elif action_data["type"] == "mouse_click":
                button = action_data.get("button", "left")
                # å·¦é”®æŒ‰ä¸‹0x03 æŠ¬èµ·0x04
                if button == "left":
                    sock.sendto(bytes.fromhex("03 01 00 00 00 00"), (device_ip, self.port))  # æŒ‰ä¸‹
                    time.sleep(0.03)
                    sock.sendto(bytes.fromhex("04 01 00 00 00 00"), (device_ip, self.port))  # æŠ¬èµ·

            self.connected_devices[device_ip]["last_heartbeat"] = time.time()
            return True
        except Exception as e:
            print(f"[Hardware] å‘é€æŒ‡ä»¤å¤±è´¥ {device_ip}: {e}")
            return False

    def start_heartbeat(self):
        """å¯åŠ¨å¿ƒè·³çº¿ç¨‹ï¼ˆæ¯5ç§’å‘ä¸€æ¬¡ä¿æ´»ï¼‰"""
        if self.heartbeat_thread is None or not self.heartbeat_thread.is_alive():
            self.running = True
            self.heartbeat_thread = threading.Thread(target=self._heartbeat_loop, daemon=True)
            self.heartbeat_thread.start()

    def _heartbeat_loop(self):
        while self.running:
            time.sleep(5)
            with self.connection_lock:
                current_time = time.time()
                for ip, info in list(self.connected_devices.items()):
                    if current_time - info["last_heartbeat"] > 15:
                        print(f"[Hardware] {ip} å¿ƒè·³è¶…æ—¶ï¼Œæ–­å¼€è¿æ¥")
                        self.disconnect_device(ip)
                        continue
                    # å‘é€å¿ƒè·³åŒ…
                    try:
                        info["sock"].sendto(bytes.fromhex("01 00 00 00 00 00"), (ip, self.port))
                    except:
                        pass

    def list_devices(self):
        with self.connection_lock:
            return list(self.connected_devices.keys())

    def stop_all(self):
        self.running = False
        with self.connection_lock:
            for ip in list(self.connected_devices.keys()):
                self.disconnect_device(ip)

# src/tools/process_mask.py
# 2025ç»ˆæä¸­å¤–èåˆåŠ¨æ€éšæœºä¼ªè£…ï¼ˆç³»ç»Ÿè¿›ç¨‹ + ä¸­å›½æœ¬åœŸè½¯ä»¶ + æ€æ¯’ + æ‰˜ç›˜å›¾æ ‡ï¼Œ150+ æ–¹æ¡ˆï¼‰

import sys
import os
import ctypes
import platform
import threading
import time
import random
from PyQt5.QtGui import QIcon

from src.tools.resource_path import resource_path

if platform.system() == "Windows":
    import win32gui
    import win32con

class ProcessMasking:
    """ç»ˆæèåˆä¼ªè£…ï¼šç³»ç»Ÿè¿›ç¨‹ + ä¸­å›½æœ¬åœŸè½¯ä»¶ + æ€æ¯’ + éšæœºæ‰˜ç›˜å›¾æ ‡"""

    FAKE_PROFILES = {
        # 1. ç»å…¸ç³»ç»Ÿè¿›ç¨‹ï¼ˆæœ€å®‰å…¨ã€æœ€å¸¸è§ä¼ªè£…ï¼‰
        "windows_system": {
            "processes": [
                "svchost.exe", "dwm.exe", "csrss.exe", "winlogon.exe", "explorer.exe",
                "taskhostw.exe", "ctfmon.exe", "sihost.exe", "RuntimeBroker.exe",
                "ShellExperienceHost.exe", "SearchIndexer.exe", "smss.exe", "wininit.exe",
                "services.exe", "lsass.exe", "fontdrvhost.exe", "conhost.exe",
                "SecurityHealthSystray.exe", "MoUsoCoreWorker.exe", "TiWorker.exe",
                "TrustedInstaller.exe", "msmpeng.exe", "nisSrv.exe", "sihost.exe"
            ],
            "titles": [
                "Desktop Window Manager", "Windows Shell Experience Host", "Program Manager",
                "Security and Maintenance", "System", "Search", "Settings", "Task Host",
                "Runtime Broker", "Font Driver Host", "Console Window Host",
                "Microsoft Windows Operating System", "Windows Security Health",
                "Windows Update", "Microsoft Defender Antivirus Service"
            ],
            "icons": ["system", "dwm", "explorer", "security", "update", "defender"]  # å¯æ”¾é€šç”¨Windowså›¾æ ‡
        },

        # 2. å³æ—¶é€šè®¯/ç¤¾äº¤
        "im_social": {
            "processes": ["WeChat.exe", "QQ.exe", "TIM.exe", "DingTalk.exe", "Feishu.exe", "EnterpriseWeChat.exe"],
            "titles": ["å¾®ä¿¡", "QQ", "TIM", "é’‰é’‰", "é£ä¹¦", "ä¼ä¸šå¾®ä¿¡", "å¾®ä¿¡ - æ­£åœ¨åŒæ­¥æ¶ˆæ¯", "QQ - æ¶ˆæ¯æé†’"],
            "icons": ["wechat", "qq", "tim", "dingtalk", "feishu", "enterprisewc"]
        },

        # 3. çŸ­è§†é¢‘/ç›´æ’­
        "video_short": {
            "processes": ["Douyin.exe", "Kuaishou.exe", "XiguaVideo.exe", "Bilibili.exe", "Youku.exe", "iQIYI.exe"],
            "titles": ["æŠ–éŸ³", "å¿«æ‰‹", "è¥¿ç“œè§†é¢‘", "å“”å“©å“”å“©", "ä¼˜é…·", "çˆ±å¥‡è‰º", "æŠ–éŸ³ - æ¨è", "Bç«™ - é¦–é¡µ"],
            "icons": ["douyin", "kuaishou", "xigua", "bilibili", "youku", "iqiyi"]
        },

        # 4. ç”µå•†/å¤–å–
        "shopping": {
            "processes": ["Taobao.exe", "JDLive.exe", "Pinduoduo.exe", "Meituan.exe", "Eleme.exe"],
            "titles": ["æ·˜å®", "äº¬ä¸œ", "æ‹¼å¤šå¤š", "ç¾å›¢", "é¥¿äº†ä¹ˆ", "æ·˜å® - é¦–é¡µ", "äº¬ä¸œ - è´­ç‰©è½¦"],
            "icons": ["taobao", "jd", "pinduoduo", "meituan", "eleme"]
        },

        # 5. æ€æ¯’/å®‰å…¨è½¯ä»¶ï¼ˆé‡ç‚¹ï¼‰
        "antivirus": {
            "processes": [
                "360safe.exe", "360tray.exe", "ZhuDongFangYu.exe", "KSafeTray.exe",
                "Huorong.exe", "HipsTray.exe", "KvMon.exe", "TxGuard.exe", "QQPCMgr.exe"
            ],
            "titles": ["360å®‰å…¨å«å£«", "360å®‰å…¨å«å£« - ä¸»é¢æ¿", "ç«ç»’å®‰å…¨", "é‡‘å±±æ¯’éœ¸", "è…¾è®¯ç”µè„‘ç®¡å®¶", "360å®æ—¶ä¿æŠ¤"],
            "icons": ["360safe", "360tray", "huorong", "kv", "txcomputer", "qqpcmgr"]
        },

        # 6. æµè§ˆå™¨
        "browser": {
            "processes": ["chrome.exe", "msedge.exe", "360chrome.exe", "QQBrowser.exe"],
            "titles": ["Chrome", "Microsoft Edge", "360å®‰å…¨æµè§ˆå™¨", "QQæµè§ˆå™¨", "æ–°æ ‡ç­¾é¡µ", "ç™¾åº¦ä¸€ä¸‹ï¼Œä½ å°±çŸ¥é“"],
            "icons": ["chrome", "msedge", "360chrome", "qqbrowser"]
        },

        # 7. ç³»ç»Ÿ/åª’ä½“/æ¸¸æˆå¹³å°
        "media_game": {
            "processes": [
                "Steam.exe", "WeGame.exe", "EpicGamesLauncher.exe",
                "PotPlayerMini64.exe", "vlc.exe", "Thunder.exe", "BaiduNetdisk.exe"
            ],
            "titles": ["Steam", "WeGame", "Epic Games", "PotPlayer", "VLC", "è¿…é›·", "ç™¾åº¦ç½‘ç›˜"],
            "icons": ["steam", "wegame", "epic", "potplayer", "vlc", "thunder", "baidunetdisk"]
        }
    }

    @staticmethod
    def get_random_fake_profile():
        category = random.choice(list(ProcessMasking.FAKE_PROFILES.keys()))
        profile = ProcessMasking.FAKE_PROFILES[category]
        fake_process = random.choice(profile["processes"])
        fake_title = random.choice(profile["titles"])
        icon_base = random.choice(profile["icons"])
        return fake_process, fake_title, icon_base, category

    @staticmethod
    def mask_process_name(fake_name: str):
        if platform.system() == "Windows":
            try:
                ctypes.windll.kernel32.SetConsoleTitleW(fake_name)
                print(f"[Mask] è¿›ç¨‹æ§åˆ¶å°æ ‡é¢˜ä¼ªè£…ä¸º: {fake_name}")
            except Exception as e:
                print(f"[Mask] è¿›ç¨‹åä¼ªè£…å¤±è´¥: {e}")

    @staticmethod
    def mask_window_title(window, fake_title: str):
        try:
            window.setWindowTitle(fake_title)
            print(f"[Mask] ä¸»çª—å£æ ‡é¢˜ä¼ªè£…ä¸º: {fake_title}")
        except Exception as e:
            print(f"[Mask] çª—å£æ ‡é¢˜ä¼ªè£…å¤±è´¥: {e}")

    @staticmethod
    def mask_tray_icon(app, icon_base_name: str):
        try:
            candidates = [
                resource_path(os.path.join("fake_icons", f"{icon_base_name}.ico")),
                resource# src/tools/resource_path.py
import os
import sys

def resource_path(relative_path):
    """
    è·å–èµ„æºçš„ç»å¯¹è·¯å¾„ï¼ˆæ”¯æŒå¼€å‘æ¨¡å¼å’ŒPyInstalleræ‰“åŒ…æ¨¡å¼ï¼‰
    
    ç”¨æ³•ç¤ºä¾‹ï¼š
    icon_path = resource_path("resources/ai_icon.png")
    QIcon(icon_path)
    
    å¼€å‘æ—¶ï¼šè¿”å›é¡¹ç›®ç›®å½•ä¸‹çš„è·¯å¾„
    æ‰“åŒ…æˆexeåï¼šè¿”å›ä¸´æ—¶è§£å‹ç›®å½•ï¼ˆ_MEIPASSï¼‰ä¸­çš„è·¯å¾„
    """
    try:
        # PyInstalleræ‰“åŒ…åä¼šåˆ›å»ºä¸€ä¸ªä¸´æ—¶æ–‡ä»¶å¤¹ï¼Œå¹¶æŠŠè·¯å¾„å­˜æ”¾åœ¨ sys._MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        # å¼€å‘æ¨¡å¼ï¼Œç›´æ¥ç”¨å½“å‰æ–‡ä»¶æ‰€åœ¨ç›®å½•
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)# ================== src/tools/utils.py ==================
import os
import datetime
import platform

class SimpleLogger:
    """
    æ–‡ä»¶æ—¥å¿—è®°å½•å™¨ï¼Œç®€å•æ˜“ç”¨
    """
    def __init__(self, log_file="run.log"):
        self.log_file = log_file

    def log(self, msg, level="INFO"):
        now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        entry = f"[{now}][{level}] {msg}\n"
        with open(self.log_file, "a", encoding="utf-8") as f:
            f.write(entry)

    def error(self, msg):
        self.log(msg, "ERROR")

    def info(self, msg):
        self.log(msg, "INFO")

def format_time(ts=None):
    """
    è¿”å›ç»Ÿä¸€çš„æ ¼å¼åŒ–æ—¶é—´å­—ç¬¦ä¸²
    """
    dt = datetime.datetime.fromtimestamp(ts) if ts else datetime.datetime.now()
    return dt.strftime("%Y-%m-%d %H:%M:%S")

def sys_platform_info():
    """
    è·å–ä¸»æœºç³»ç»Ÿä¸Pythonç¯å¢ƒä¿¡æ¯
    """
    info = {
        "platform": platform.platform(),
        "python": platform.python_version(),
        "machine": platform.machine(),
        "uptime": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    return info

def mkdir_if_not_exists(path):
    """
    è‹¥ç›®å½•ä¸å­˜åœ¨åˆ™è‡ªåŠ¨åˆ›å»º
    """
    if not os.path.exists(path):
        os.makedirs(path, exist_ok=True)
        return True
    return False

# ================== src/tools/utils.py å®Œï¼Œä¸‹ä¸€æ­¥ src/tools/process_mask.pyï¼ˆè¿›ç¨‹/çª—å£ä¼ªè£…ï¼‰ ==================

# æ‹¼æ¥è¯´æ˜ï¼šå¸¸ç”¨å·¥å…·å‡½æ•°å·²å®ç°ã€‚
# ä¸‹ä¸€æ­¥è¯·åœ¨ src/tools ä¸‹æ–°å»º process_mask.pyï¼Œç­‰å¾…å®‰å…¨è¿›ç¨‹/çª—å£ä¼ªè£…é€»è¾‘æ¨¡å—ã€‚# ================== src/ui/dialogs.py ==================
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QLineEdit, QTableWidget, 
    QTableWidgetItem, QHeaderView, QAbstractItemView, QMessageBox, QComboBox, 
    QProgressBar, QSpacerItem, QSizePolicy
)
from PyQt5.QtCore import Qt, QTimer, QPropertyAnimation, QRect
from PyQt5.QtGui import QIcon, QColor, QBrush, QPixmap, QPainter, QPen
import random
import datetime

class SettingsDialog(QDialog):
    """
    é€šç”¨è®¾ç½®çª—å£ï¼Œå¯æ‰©å±•å„ç±»åå¥½/é«˜çº§å‚æ•°é…ç½®
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("ç³»ç»Ÿè®¾ç½®")
        self.setFixedSize(420, 320)
        layout = QVBoxLayout()
        # æ¼”ç¤ºï¼šå¯æ·»åŠ å¤šä¸ªè®¾ç½®é¡¹
        layout.addWidget(QLabel("åŠŸèƒ½è®¾ç½®åŒºï¼Œæ›´å¤šå‚æ•°è¯·åœ¨src/ui/dialogs.pyå®Œå–„..."))
        self.setLayout(layout)


class KamiDialog(QDialog):
    """
    å¡å¯†åå°ç³»ç»Ÿï¼šç”Ÿæˆã€å†»ç»“ã€åˆ é™¤ã€å¡å¯†åˆ—è¡¨ã€æ‰¹é‡ç¾åŒ–ã€ç²’å­åº†ç¥
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("å¡å¯†åå°ï¼ˆç”Ÿæˆ/å†»ç»“/ä»¿çœŸï¼‰")
        self.setFixedSize(640, 480)
        self._setup_ui()
        self._init_data()
        self._refresh_table()

    def _setup_ui(self):
        layout = QVBoxLayout()
        hl = QHBoxLayout()
        hl.addWidget(QLabel("ç”Ÿæˆæ•°é‡ï¼š"))
        self.num_box = QComboBox()
        self.num_box.addItems(["1","10","50","100"])
        hl.addWidget(self.num_box)
        self.btn_gen = QPushButton("ç”Ÿæˆ")
        self.btn_gen.clicked.connect(self._on_generate)
        hl.addWidget(self.btn_gen)
        # è¿›åº¦æ¡
        self.progress = QProgressBar()
        self.progress.hide()
        hl.addWidget(self.progress)
        hl.addStretch()
        layout.addLayout(hl)
        # è¡¨æ ¼å±•ç¤º
        self.table = QTableWidget(0, 7)
        self.table.setHorizontalHeaderLabels([
            "å¡å¯†", "ç±»å‹", "å¤‡æ³¨", "IP", "HWID", "åˆ°æœŸ", "çŠ¶æ€"
        ])
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self._on_context_menu)
        layout.addWidget(self.table)
        # ç²‰è‰²ç²’å­åŠ¨ç”»åŒºåŸŸ
        self.anim_widget = ParticleWidget(self)
        layout.addWidget(self.anim_widget)
        layout.addSpacing(10)
        self.setLayout(layout)

    def _init_data(self):
        # å‡è®¾ç”¨å†…å­˜ç»“æ„ä¿å­˜ï¼ˆå®é™…å¯æ¥API/æ•°æ®åº“ï¼‰
        self.kami_list = []   # [dict(kami, type, ...)]
        self._load_data()

    def _load_data(self):
        # å¯ä»¥åŠ è½½æ•°æ®åº“/ç£ç›˜/äº‘API
        # è¿™é‡Œä»…æ¨¡æ‹Ÿç”Ÿæˆéƒ¨åˆ†å‡æ•°æ®
        for i in range(10):
            self.kami_list.append({
                "kami": f"KAMI2025A00{i}",
                "type": random.choice(["1å¤©", "7å¤©", "1æœˆ", "æ°¸ä¹…"]),
                "note": f"å¤‡æ³¨{i}",
                "ip": "8.8.8.8",
                "hwid": "ABCD-1234-5678-999{}".format(i),
                "exp": (datetime.datetime.now() + datetime.timedelta(days=30)).strftime('%Y-%m-%d'),
                "state": "å·²ä½¿ç”¨" if i % 2 == 0 else "æœªæ¿€æ´»"
            })

    def _refresh_table(self):
        self.table.setRowCount(len(self.kami_list))
        for row, k in enumerate(self.kami_list):
            for col, key in enumerate(["kami", "type", "note", "ip", "hwid", "exp", "state"]):
                item = QTableWidgetItem(str(k.get(key, "")))
                self.table.setItem(row, col, item)

    def _on_generate(self):
        # æ‰¹é‡ç”Ÿæˆå¸¦è¿›åº¦æ¡å’Œç²’å­åŠ¨ç”»
        try:
            count = int(self.num_box.currentText())
        except:
            count = 10
        self.progress.setMaximum(count)
        self.progress.setValue(0)
        self.progress.show()
        self.btn_gen.setEnabled(False)
        self.anim_widget.hide()
        self._gen_count = count
        self._now_gen = 0
        self._timer = QTimer(self)
        self._timer.timeout.connect(self._gen_tick)
        self._timer.start(50)

    def _gen_tick(self):
        if self._now_gen >= self._gen_count:
            self._timer.stop()
            self.progress.hide()
            self.btn_gen.setEnabled(True)
            self.anim_widget.start_particles()
            self._refresh_table()
            return
        # éšæœºç”Ÿæˆå‡å¡å¯†
        idx = len(self.kami_list) + 1
        kami = f"KAMI{random.randint(100000,999999)}"
        self.kami_list.append({
            "kami": kami,
            "type": random.choice(["1å°æ—¶", "12å°æ—¶", "1å¤©", "7å¤©", "1æœˆ", "1å­£åº¦", "1å¹´"]),
            "note": "æ‰¹é‡ç”Ÿæˆ",
            "ip": "æœªæ¿€æ´»",
            "hwid": "",
            "exp": (datetime.datetime.now() + datetime.timedelta(days=365)).strftime('%Y-%m-%d'),
            "state": "æœªæ¿€æ´»"
        })
        self._now_gen += 1
        self.progress.setValue(self._now_gen)

    def _on_context_menu(self, pos):
        row = self.table.currentRow()
        if row >= 0:
            menu = QMenu(self)
            act_freeze = menu.addAction("å†»ç»“")
            act_delete = menu.addAction("åˆ é™¤")
       p[1] += random.randint(3, 7)
            p[0] += p[2]
        if self.seeds and max(x[1] for x in self.seeds) > self.height():
            self.seeds = []
            self.hide()
            self.timer.stop()
        self.update()

    def paintEvent(self, event):
        qp = QPainter(self)
        for x, y, v, c, scale in self.seeds:
            qp.setPen(Qt.NoPen)
            qp.setBrush(QBrush(c))
            qp.drawEllipse(x, y, int(21*scale), int(18*scale))


class AboutDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("å…³äº å®‰é™AIè§†è§‰è¾…åŠ©å¹³å°")
        self.setFixedSize(360, 220)
        layout = QVBoxLayout()
        txt = QLabel("å®‰é™ä¸“å±é¡¶çº§AIè§†è§‰æŠ€æœ¯\nç‰ˆæœ¬ 1.0\n\nä¸ºPCç«¯ä¹å¤§ä¸»æµå°„å‡»ç½‘æ¸¸å…¨ç³»æ‰“é€ \nèåˆæœ€æ–°YOLOè§†è§‰AIã€å¤šå¤–è®¾ã€æè‡´å®‰å…¨é˜²æ£€æµ‹ã€ä¸ƒå¤§çš®è‚¤ä¸»é¢˜\né¡¹ç›®å¼€æº/ç§ç”¨å‡å¯ï¼Œå•†ç”¨è¯·æˆæƒï¼\n\næ„Ÿè°¢æ‚¨çš„ä¿¡ä»»ä¸ä½“éªŒï¼")
        txt.setAlignment(Qt.AlignCenter)
        txt.setStyleSheet("font-size:15px;")
        layout.addWidget(txt)
        self.setLayout(layout)

# ================== src/ui/dialogs.py å®Œï¼Œä¸‹ä¸€æ­¥ src/ui/radar.pyï¼ˆç‹¬ç«‹é›·è¾¾çª—å£ï¼‰å¼€å§‹ ==================

# æ‹¼æ¥è¯´æ˜ï¼šå¼¹çª—/å¡å¯†/è®¾ç½®/ç²’å­åŠ¨ç”»å‡å·²å®ç°ã€‚
# ä¸‹ä¸€æ­¥è¯·åœ¨ src/ui/ æ–°å»º radar.pyï¼Œç­‰å¾…ä¸‹ä¸€ä¸ªæ¨¡å—ã€‚# src/ui/esp_overlay.py
# 2025å¹´ç‹¬ç«‹é€è§†å åŠ çª—ï¼ˆESPé€è§†ç»ˆæç‰ˆï¼‰

from PyQt5.QtWidgets import QWidget
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QPainter, QPen, QBrush, QFont, QColor

from src.core.yolo_ai import visual_core
from src.core.screenshot import game_capture
from src.config.config import load_config

import math

class ESPOverlay(QWidget):
    """
    ç‹¬ç«‹é€è§†å åŠ çª—
    - é€æ˜èƒŒæ™¯ + ç‚¹å‡»ç©¿é€ + å§‹ç»ˆç½®é¡¶
    - å®æ—¶ç»˜åˆ¶ESPï¼šæ–¹æ¡† + éª¨éª¼ + åå­— + è·ç¦» + è¡€æ¡
    - é¢œè‰²ä»å½“å‰æ¸¸æˆé…ç½®è¯»å–
    - çƒ­é”®F3å¼€å…³ï¼ˆåœ¨main_windowæ³¨å†Œï¼‰
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("å®‰é™AI - ESPé€è§†å åŠ çª—")
        self.setWindowFlags(
            Qt.FramelessWindowHint |           # æ— è¾¹æ¡†
            Qt.WindowStaysOnTopHint |          # å§‹ç»ˆç½®é¡¶
            Qt.Tool |                          # ä¸æ˜¾ç¤ºåœ¨ä»»åŠ¡æ 
            Qt.WindowTransparentForInput       # ç‚¹å‡»ç©¿é€ï¼ˆé¼ æ ‡æ“ä½œé€åˆ°æ¸¸æˆï¼‰
        )
        self.setAttribute(Qt.WA_TranslucentBackground, True)  # é€æ˜èƒŒæ™¯

        # å…¨å±è¦†ç›–ä¸»æ˜¾ç¤ºå™¨
        screen = QApplication.primaryScreen().geometry()
        self.setGeometry(screen)

        self.visible = True
        self.targets = []

        # å®æ—¶æ›´æ–°
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_esp)
        self.timer.start(16)  # ~60FPS

        print("[ESP] é€è§†å åŠ çª—å·²åˆ›å»ºï¼ˆF3å¼€å…³ï¼‰")

    def toggle_visibility(self):
        """å¼€å…³é€è§†çª—"""
        self.visible = not self.visible
        if self.visible:
            self.show()
            self.raise_()
            self.activateWindow()
            print("[ESP] é€è§†å·²å¼€å¯")
        else:
            self.hide()
            print("[ESP] é€è§†å·²å…³é—­")

    def update_esp(self):
        """æ¯å¸§æ›´æ–°æ£€æµ‹ç»“æœ"""
        img = game_capture.capture()
        if img is not None:
            self.targets = visual_core.infer(img, conf=0.35, classes=[0])
        self.update()  # è§¦å‘é‡ç»˜

    def paintEvent(self, event):
        if not self.visible:
            return

        if not self.targets:
            return

        qp = QPainter(self)
        qp.setRenderHint(QPainter.Antialiasing)

        # å½“å‰æ¸¸æˆé…ç½®ï¼ˆç”¨äºè¯»å–ESPé¢œè‰²ï¼‰
        config = load_config()
        # å‡è®¾ä»ä¸»çª—å£è·å–å½“å‰Tabï¼ˆè¿™é‡Œç®€åŒ–ç”¨CFä½œä¸ºé»˜è®¤ï¼‰
        current_game = "CF"  # å®é™…åº”ä»ä¸»çª—å£ä¼ é€’å½“å‰æ¸¸æˆkey
        esp_color_hex = config.get("game_params", {}).get(current_game, {}).get("esp_color", "#FF6464")
        esp_color = QColor(esp_color_hex)
        esp_color.setAlpha(220)

        line_pen = QPen(esp_color, 2)
        box_pen = QPen(esp_color, 3)
        text_font = QFont("Microsoft YaHei", 10, QFont.Bold)
        small_font = QFont("Microsoft YaHei", 8)

        for target in self.targets:
            if "box" not in target or "keypoints" not in target:
                continue

            box = target["box"]
            kps = target["keypoints"]

            x1, y1, x2, y2 = map(int, box)

            # 2Dæ–¹æ¡†
            qp.setPen(box_pen)
            qp.setBrush(Qt.NoBrush)
            qp.drawRect(x1, y1, x2 - x1, y2 - y1)

            # ä¸­å¿ƒç‚¹
            center_x = (x1 + x2) // 2
            center_y = (y1 + y2) // 2

            # åå­— + è·ç¦»
            name = target.get("name", "æ•Œäºº")
            distance = int(math.hypot(center_x - self.width() // 2, center_y - self.height() // 2) / 15)
            qp.setPen(QColor(255, 255, 255))
            qp.setFont(text_font)
            qp.drawText(center_x - 50, y1 - 10, f"{name} {distance}m")

            # è¡€æ¡
            hp = random.randint(20, 100)  # æ¨¡æ‹Ÿè¡€é‡
            bar_width = x2 - x1
            bar_height = 10
            qp.setBrush(QBrush(QColor(50, 50, 50)))
            qp.drawRect(x1, y1 - 25, bar_width, bar_height)
            hp_color = QColor(0, 255, 0) if hp > 50 else QColor(255, 255, 0) if hp > 25 else QColor(255, 0, 0)
            qp.setBrush(QBrush(hp_color))
            qp.drawRect(x1, y1 - 25, int(bar_width * hp / 100), bar_height)

            # éª¨éª¼çº¿ï¼ˆCOCOæ ‡å‡†è¿æ¥ï¼‰
            connections = [
                (0, 1), (1, 2), (0, 3), (3, 4),           # å¤´éƒ¨
                (1, 5), (2, 6),                           # è‚©è†€
                (5, 7), (7, 9), (6, 8), (8, 10),          # æ‰‹è‡‚
                (5, 11), (6, 12), (11, 13), (12, 14),     # è…¿éƒ¨
                (13, 15), (14, 16)                        # è„š
            ]
            qp.setPen(line_pen)
            for a, b in connections:
                if a < len(kps) and b < len(kps):
                    ax, ay = kps[a]
                    bx, by = kps[b]
                    if ax > 0 and ay > 0 and bx > 0 and by > 0:
                        qp.drawLine(int(ax), int(ay), int(bx), int(by))

        qp.end()# src/ui/login.py
# çº¯æœ¬åœ°ç»ˆæå¡å¯†éªŒè¯ï¼ˆå¸¦å‰©ä½™æ—¶é—´ + è§£ç»‘æ‰£2å°æ—¶ï¼‰

from PyQt5.QtWidgets import (
    QDialog, QLabel, QLineEdit, QVBoxLayout, QHBoxLayout, QPushButton,
    QMessageBox, QCheckBox, QWidget, QSpacerItem, QSizePolicy
)
from PyQt5.QtGui import QIcon
from PyQt5.QtCore import Qt
import uuid
import hashlib
import subprocess
import datetime
import os
import json

from src.config.config import _get_fernet
from appdirs import user_config_dir

# åè°ƒè¯•
import ctypes
if ctypes.windll.kernel32.IsDebuggerPresent():
    import sys
    sys.exit(0)

class LoginDialog(QDialog):
    def __init__(self, theme_manager, parent=None):
        super().__init__(parent)
        self.theme_manager = theme_manager
        self.setWindowTitle("ç™»å½• - å®‰é™AIè§†è§‰æŠ€æœ¯")
        self.setWindowFlags(self.windowFlags() & ~Qt.WindowContextHelpButtonHint)
        self.setFixedSize(420, 340)

        self.bind_file = os.path.join(user_config_dir("AnjingAI"), "bind.dat")

        main_layout = QVBoxLayout()
        l_title = QLabel("è´¦å·ç™»å½•")
        l_title.setStyleSheet("font-size: 18px; font-weight: bold; margin: 10px;")
        l_title.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(l_title)

        h_kami = QHBoxLayout()
        self.le_kami = QLineEdit()
        self.le_kami.setPlaceholderText("è¯·è¾“å…¥å¡å¯†...")
        h_kami.addWidget(self.le_kami, 5)

        btn_unbind = QPushButton("è§£ç»‘æ¢æœº")
        btn_unbind.setToolTip("è§£ç»‘æœ¬æœºï¼Œæ‰£é™¤2å°æ—¶å‰©ä½™æ—¶é—´")
        btn_unbind.clicked.connect(self.unbind_hwid)
        h_kami.addWidget(btn_unbind, 3)
        main_layout.addLayout(h_kami)

        self.cb_autologin = QCheckBox("ä¸‹æ¬¡è‡ªåŠ¨ç™»å½•")
        self.cb_autologin.setChecked(True)
        main_layout.addWidget(self.cb_autologin)

        btn_layout = QHBoxLayout()
        btn_login = QPushButton("ç™»å½•éªŒè¯")
        btn_login.clicked.connect(self._do_login)
        btn_layout.addStretch()
        btn_layout.addWidget(btn_login)
        btn_layout.addStretch()
        main_layout.addLayout(btn_layout)

        self.le_hwid = QLineEdit(self.get_hwid()[:16] + "...")
        self.le_hwid.setReadOnly(True)
        self.le_hwid.setToolTip("å½“å‰è®¾å¤‡è¯†åˆ«ç ï¼ˆå·²åŠ å¼ºï¼‰")
        main_layout.addWidget(self.le_hwid)

        tip = QLabel("é¦–æ¬¡ä½¿ç”¨éœ€è¾“å…¥å¡å¯†ç»‘å®šæœ¬æœºï¼Œæ¢æœºç‚¹å‡»è§£ç»‘ï¼ˆæ‰£2å°æ—¶ï¼‰ã€‚")
        tip.setStyleSheet("color:gray;font-size:12px;")
        tip.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(tip)

        self.setLayout(main_layout)
        self.user_info = None

        self.try_auto_login()

    def get_hwid(self):
        hwid_parts = []
        try:
            result = subprocess.check_output("wmic diskdrive get serialnumber", shell=True, encoding='utf-8')
            hwid_parts.append(result.strip())
        except:
            pass
        try:
            result = subprocess.check_output("wmic cpu get processorid", shell=True, encoding='utf-8')
            hwid_parts.append(result.strip())
        except:
            pass
        try:
            result = subprocess.check_output("wmic csproduct get uuid", shell=True, encoding='utf-8')
            hwid_parts.append(result.strip())
        except:
            pass
        hwid_parts.append(str(uuid.getnode()))
        raw = "".join(hwid_parts).encode('utf-8', errors='ignore')
        return hashlib.sha256(raw).hexdigest().upper()

    def try_auto_login(self):
        if not self.cb_autologin.isChecked() or not os.path.exists(self.bind_file):
            return

        try:
            f = _get_fernet()
            with open(self.bind_file, "rb") as fh:
                enc = fh.read()
                data = json.loads(f.decrypt(enc).decode('utf-8'))

            current_hwid = self.get_hwid()
            if data["hwid"] == current_hwid:
                # è®¡ç®—å‰©ä½™æ—¶é—´
                remaining = self.calculate_remaining(data)
                if remaining <= 0 and data["total_hours"] != "permanent":
                    QMessageBox.critical(self, "å¡å¯†è¿‡æœŸ", "å¡å¯†å·²è¿‡æœŸï¼Œè¯·è”ç³»ä½œè€…ç»­è´¹ã€‚")
                    os.remove(self.bind_file)
                    return

                self.user_info = {
                    "kami": data["kami"],
                    "hwid": current_hwid,
                    "type": data.get("type", "user"),
                    "expire_time": data.get("expire_time", "æ°¸ä¹…"),
                    "remaining_hours": remaining if data["total_hours"] != "permanent" else "æ°¸ä¹…"
                }
                self.accept()
        except Exception:
            pass

    def calculate_remaining(self, data):
        if data["total_hours"] == "permanent":
            return "æ°¸ä¹…"

        total = data["total_hours"]
        used = data.get("used_hours", 0.0)
        last_login = datetime.datetime.fromisoformat(data.get("last_login", datetime.datetime.now().isoformat()))
        now = datetime.datetime.now()
        session_hours = (now - last_login).total_seconds() / 3600
        used += session_hours

        remaining = total - used
        return max(0, remaining)

    def unbind_hwid(self):
        if not os.path.exists(self.bind_file):
            QMessagif data["hwid"] != hwid:
                    QMessageBox.critical(self, "ç»‘å®šå¤±è´¥", "æ­¤å¡å¯†å·²ç»‘å®šå…¶ä»–è®¾å¤‡ï¼")
                    return
            except:
                QMessageBox.critical(self, "éªŒè¯å¤±è´¥", "ç»‘å®šæ–‡ä»¶æŸå")
                return
        else:
            # é¦–æ¬¡ç»‘å®š
            bind_data = {
                "kami": kami,
                "hwid": hwid,
                "total_hours": card_info["total_hours"],
                "used_hours": 0.0,
                "last_login": datetime.datetime.now().isoformat(),
                "type": card_info["type"]
            }
            try:
                f = _get_fernet()
                enc = f.encrypt(json.dumps(bind_data).encode('utf-8'))
                os.makedirs(os.path.dirname(self.bind_file), exist_ok=True)
                with open(self.bind_file, "wb") as fh:
                    fh.write(enc)
            except Exception as e:
                QMessageBox.critical(self, "ç»‘å®šå¤±è´¥", str(e))
                return

        # è®¡ç®—å‰©ä½™æ—¶é—´
        remaining = card_info["total_hours"] if card_info["total_hours"] == "permanent" else card_info["total_hours"]

        self.user_info = {
            "kami": kami,
            "hwid": hwid,
            "type": card_info["type"],
            "expire_time": "æ°¸ä¹…" if card_info["total_hours"] == "permanent" else f"å‰©ä½™ {remaining} å°æ—¶",
            "remaining_hours": remaining
        }
        self.accept()

    def get_user_info(self):
        return self.user_info or {}# src/ui/main_window.py
# 2025å¹´æ——èˆ°é£æ ¼UIå®Œæ•´ç‰ˆï¼ˆå·¦ä¾§9æ¸¸æˆç«–æ’ + å³ä¾§å‚æ•° + æŠ˜å é«˜çº§ + æˆªå›¾åˆ‡æ¢ + é…ç½®çƒ­é‡è½½ï¼‰

from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel,
    QAction, QMenu, QStatusBar, QSplitter, QListWidget, QListWidgetItem,
    QGroupBox, QGridLayout, QScrollArea, QToolBox, QFrame, QSlider, QCheckBox,
    QColorDialog, QComboBox
)
from PyQt5.QtCore import Qt, QTimer, QSize
from PyQt5.QtGui import QIcon, QColor, QFont, QPixmap, QPainter, QPen, QBrush, QLinearGradient

from .theme import ThemeManager
from .stats import StatsWindow
from .esp_overlay import ESPOverlay
from src.tools.resource_path import resource_path
from src.config.config import load_config, load_all_configs
from src.core.hotkeys import HotkeyManager
from src.core.cheats import cheat_service
from src.core.yolo_ai import visual_core
from src.devices.hardware import hardware_manager
from src.core.screenshot import ScreenshotManager, game_capture  # å…¨å±€game_capture

import os
import time

# ============ å‹æªæ›²çº¿ç¼–è¾‘å™¨ ============
class CurveEditor(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(500, 250)
        self.setStyleSheet("background-color: #1e1e2e; border: 1px solid #444; border-radius: 10px;")
        self.curve = [0.0] * 30
        self.drawing = False

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.drawing = True
            self.update_point(event.pos())

    def mouseMoveEvent(self, event):
        if self.drawing:
            self.update_point(event.pos())

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.drawing = False
            if hasattr(self, "save_callback"):
                self.save_callback(self.get_curve())

    def update_point(self, pos):
        x = max(0, min(pos.x(), self.width() - 1))
        y = max(0, min(pos.y(), self.height() - 1))
        idx = int(x / self.width() * len(self.curve))
        if 0 <= idx < len(self.curve):
            max_offset = 60.0
            self.curve[idx] = (y / self.height()) * max_offset
        self.update()

    def paintEvent(self, event):
        qp = QPainter(self)
        qp.setRenderHint(QPainter.Antialiasing)
        qp.fillRect(self.rect(), QColor(30, 30, 46))

        # ç½‘æ ¼
        qp.setPen(QPen(QColor(80, 80, 80), 1, Qt.DashLine))
        for i in range(1, 6):
            y = int(self.height() * i / 6)
            qp.drawLine(0, y, self.width(), y)

        # æ›²çº¿
        qp.setPen(QPen(QColor(0, 170, 255), 4))
        points = []
        for i, v in enumerate(self.curve):
            x = int(i / len(self.curve) * self.width())
            y = int(self.height() - (v / 60.0 * self.height()))
            points.append((x, y))

        if len(points) > 1:
            for i in range(len(points) - 1):
                qp.drawLine(points[i][0], points[i][1], points[i+1][0], points[i+1][1])

        # æ–‡å­—
        qp.setPen(QColor(200, 200, 200))
        qp.setFont(QFont("Microsoft YaHei", 10))
        qp.drawText(20, 30, "å‹æªæ›²çº¿ç¼–è¾‘ï¼ˆé¼ æ ‡æ‹–åŠ¨ç»˜åˆ¶ï¼‰")

    def get_curve(self):
        return self.curve[:]

    def set_curve(self, curve):
        if len(curve) == len(self.curve):
            self.curve = curve[:]
            self.update()

# ============ ä¸»çª—å£ ============
class MainWindow(QMainWindow):
    def __init__(self, user_info, theme_manager: ThemeManager, parent=None):
        super().__init__(parent)
        self.user_info = user_info
        self.theme_manager = theme_manager
        self.setWindowTitle("å®‰é™AI - é¡¶çº§è§†è§‰æŠ€æœ¯")
        self.setWindowIcon(QIcon(resource_path("resources/ai_icon.ico")))
        self.setGeometry(100, 50, 1600, 1000)

        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.main_layout = QHBoxLayout(self.central_widget)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_layout.setSpacing(0)

        # å·¦ä¾§æ¸¸æˆåˆ—è¡¨
        self.setup_game_list()

        # åˆ†éš”
        splitter = QSplitter(Qt.Horizontal)
        splitter.addWidget(self.game_list_widget)

        # å³ä¾§é¢æ¿
        self.right_panel = QWidget()
        self.right_layout = QVBoxLayout(self.right_panel)
        self.right_layout.setContentsMargins(20, 20, 20, 20)
        self.setup_right_panel()

        splitter.addWidget(self.right_panel)
        splitter.setSizes([350, 1250])

        self.main_layout.addWidget(splitter)

        # çƒ­é”®
        self.hotkey_mgr = HotkeyManager(self)
        self.hotkey_mgr.install_on_widget(self)
        self.hotkey_mgr.register_hotkey("åˆ‡æ¢é€è§†", Qt.Key_F3, callback=self.toggle_esp)
        self.hotkey_mgr.register_hotkey("çƒ­é‡è½½é…ç½®", Qt.Key_R, Qt.ControlModifier | Qt.AltModifier, callback=self.reload_config)

        # é€è§†çª—
        self.esp_overlay = ESPOverlay(self)
        self.esp_overlay.hide()

        # ç¡¬ä»¶åˆ·æ–°
        self.hardware_timer = QTimer(self)
        self.hardware_timer.timeout.connect(self.update_status)
        self.hardwcapture_layout.addWidget(self.capture_combo)
        capture_layout.addStretch()

        capture_group.setLayout(capture_layout)
        self.right_layout.addWidget(capture_group)

        # ============ ä¸€é”®åˆ·æ–°é…ç½®æŒ‰é’® ============
        refresh_group = QGroupBox("é…ç½®ç®¡ç†")
        refresh_group.setStyleSheet("QGroupBox { font-size: 16px; font-weight: bold; color: #FFAA00; }")
        refresh_layout = QHBoxLayout()

        self.refresh_btn = QPushButton("ğŸ”„ åˆ·æ–°é…ç½®")
        self.refresh_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #FFAA00, stop:1 #CC8800);
                color: white;
                font-size: 16px;
                font-weight: bold;
                padding: 10px;
                border-radius: 8px;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #FFCC00, stop:1 #DD9900);
            }
        """)
        self.refresh_btn.clicked.connect(self.reload_config)
        refresh_layout.addWidget(self.refresh_btn)
        refresh_layout.addStretch()

        refresh_group.setLayout(refresh_layout)
        self.right_layout.addWidget(refresh_group)

        # å‚æ•°æ»šåŠ¨åŒº
        self.scroll = QScrollArea()
        self.scroll.setStyleSheet("background-color: transparent;")
        self.scroll_widget = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_widget)
        self.scroll_layout.setSpacing(20)

        self.scroll.setWidget(self.scroll_widget)
        self.scroll.setWidgetResizable(True)
        self.right_layout.addWidget(self.scroll)

    # ==============================================
    # ç±»æ–¹æ³•

    def change_capture_mode(self, index):
        """æˆªå›¾æ¨¡å¼åˆ‡æ¢é€»è¾‘"""
        global game_capture

        modes = ["dxgi_thread", "dxgi", "handle", "mss"]
        new_mode = modes[index]

        print(f"[æˆªå›¾] æ­£åœ¨åˆ‡æ¢åˆ°æ¨¡å¼: {new_mode.upper()}")

        # åœæ­¢æ—§çº¿ç¨‹
        try:
            if hasattr(game_capture, 'stop'):
                game_capture.stop()
                time.sleep(0.1)
        except:
            pass
# åˆ›å»ºæ–°å®ä¾‹
        game_capture = ScreenshotManager(mode=new_mode)

        # å¤šçº¿ç¨‹æ¨¡å¼å¯åŠ¨åå°æˆªå›¾
        if new_mode == "dxgi_thread":
            game_capture.start_continuous(self.on_new_frame)

        self.statusBar().showMessage(f"æˆªå›¾æ¨¡å¼åˆ‡æ¢ä¸º: {self.capture_combo.currentText()}", 3000)

    def on_new_frame(self, frame):
        """å¤šçº¿ç¨‹æ¨¡å¼ä¸‹æ”¶åˆ°æ–°å¸§çš„å›è°ƒ"""
        if frame is None:
            return

        targets = visual_core.infer(frame)

        if hasattr(self, 'esp_overlay') and self.esp_overlay.isVisible():
            self.esp_overlay.targets = targets
            self.esp_overlay.update()

    def reload_config(self):
        """çƒ­é‡è½½é…ç½®ï¼ˆæŒ‰é’®æˆ–çƒ­é”®è§¦å‘ï¼‰"""
        from src.config.config import load_all_configs

        load_all_configs()

        self.statusBar().showMessage("âœ… é…ç½®å·²åˆ·æ–°ï¼", 5000)

        if hasattr(self, 'refresh_btn'):
            original_style = self.refresh_btn.styleSheet()
            self.refresh_btn.setText("âœ” å·²åˆ·æ–°")
            self.refresh_btn.setStyleSheet("""
                QPushButton {
                    background: #00AA00;
                    color: white;
                    font-size: 16px;
                    font-weight: bold;
                    padding: 10px;
                    border-radius: 8px;
                }
            """)
            self.refresh_btn.setEnabled(False)

            QTimer.singleShot(2000, lambda: (
                self.refresh_btn.setText("ğŸ”„ åˆ·æ–°é…ç½®"),
                self.refresh_btn.setStyleSheet(original_style),
                self.refresh_btn.setEnabled(True)
            ))

        current_row = self.game_list_widget.currentRow()
        if current_row >= 0:
            self.on_game_selected(current_row)

        print("[Config] é…ç½®çƒ­é‡è½½å®Œæˆ")

    def update_status(self):
        devices = hardware_manager.list_devices()
        count = len(devices)
        status = "åœ¨çº¿" if count > 0 else "ç¦»çº¿"
        self.l_hardware.setText(f"ç¡¬ä»¶ï¼š{count}å° | çŠ¶æ€ï¼š{status}")

    def toggle_esp(self):
        self.esp_overlay.toggle_visibility()

    # ... ä½ çš„å…¶ä»–æ–¹æ³•ï¼ˆå¦‚ on_game_selected, update_right_panel, setup_game_list ç­‰ä¿æŒä¸å˜ï¼‰ ...

    def setup_game_list(self):
        self.game_list_widget = QListWidget()
        self.game_list_widget.setStyleSheet("""
            QListWidget {
                background-color: rgba(20, 20, 40, 240);
                border: none;
            }
            QListWidget::item {
                padding: 15px;
                margin: 5px;
                border-radius: 10px;
            }
            QListWidget::item:selected {
                background-color: rgba(0, 170, 255, 100);
                border-left: 6px solid #00AAFF;
            }
        """)
        self.game_list_widget.setIconSize(QSize(140, 140))
        self.game_list_widget.setSpacing(10)
        self.game_list_widget.setViewMode(QListWidget.IconMode)
        self.game_list_widget.setFlow(QListWidget.TopToBottom)
         # åŸºç¡€åŠŸèƒ½
        basic_group = QGroupBox("åŸºç¡€åŠŸèƒ½")
        basic_group.setStyleSheet("QGroupBox { font-size: 18px; font-weight: bold; color: #00AAFF; border: none; }")
        basic_layout = QGridLayout()
        basic_layout.setSpacing(20)

        row = 0
        aim_check = QCheckBox("å¯ç”¨è‡ªç„")
        aim_check.setStyleSheet("font-size: 16px;")
        aim_check.setChecked(param.get("aim_enabled", True))
        aim_check.stateChanged.connect(lambda state: self.set_param(game_key, "aim_enabled", state == Qt.Checked))
        basic_layout.addWidget(aim_check, row, 0)
        row += 1

        esp_check = QCheckBox("å¯ç”¨é€è§†")
        esp_check.setStyleSheet("font-size: 16px;")
        esp_check.setChecked(param.get("esp_enabled", True))
        esp_check.stateChanged.connect(lambda state: self.set_param(game_key, "esp_enabled", state == Qt.Checked))
        basic_layout.addWidget(esp_check, row, 0)
        row += 1

        recoil_check = QCheckBox("å¯ç”¨å‹æª")
        recoil_check.setStyleSheet("font-size: 16px;")
        recoil_check.setChecked(param.get("recoil_compensate", False))
        recoil_check.stateChanged.connect(lambda state: self.set_param(game_key, "recoil_compensate", state == Qt.Checked))
        basic_layout.addWidget(recoil_check, row, 0)
        row += 1

        auto_fire_check = QCheckBox("è‡ªåŠ¨å¼€ç«")
        auto_fire_check.setStyleSheet("font-size: 16px;")
        auto_fire_check.setChecked(param.get("auto_fire_enabled", False))
        auto_fire_check.stateChanged.connect(lambda state: self.set_param(game_key, "auto_fire_enabled", state == Qt.Checked))
        basic_layout.addWidget(auto_fire_check, row, 0)
        row += 1

        start_btn = QPushButton("å¼€å§‹å®æ—¶æ¨ç†")
        start_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #00AAFF, stop:1 #0088CC);
                color: white;
                font-size: 24px;
                font-weight: bold;
                padding: 30px;
                border-radius: 15px;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #00CCFF, stop:1 #0099DD);
            }
        """)
        start_btn.setFixedHeight(100)
        start_btn.clicked.connect(lambda: cheat_service.start_cheat(game_key, param))
        basic_layout.addWidget(start_btn, row, 0)

        basic_group.setLayout(basic_layout)
        self.scroll_layout.addWidget(basic_group)

        # é«˜çº§è®¾ç½®æŠ˜å 
        advanced = QToolBox()
        advanced.setStyleSheet("""
            QToolBox::tab {
                background: #2d2d44;
                color: white;
                padding: 15px;
                font-size: 16px;
                border-radius: 10px;
                margin-bottom: 5px;
            }
            QToolBox::tab:selected {
                background: #00AAFF;
            }
        """)

        # ç„å‡†è®¾ç½®
        aim_page = QWidget()
        aim_layout = QGridLayout(aim_page)
        aim_layout.setSpacing(20)

        aim_layout.addWidget(QLabel("è‡ªç„FOV:"), 0, 0)
        fov_slider = QSlider(Qt.Horizontal)
        fov_slider.setRange(20, 300)
        fov_slider.setValue(param.get("aim_fov", 100))
        fov_slider.valueChanged.connect(lambda v: self.set_param(game_key, "aim_fov", v))
        aim_layout.addWidget(fov_slider, 0, 1)
        aim_layout.addWidget(QLabel("100"), 0, 2)

        aim_layout.addWidget(QLabel("missç‡:"), 1, 0)
        miss_slider = QSlider(Qt.Horizontal)
        miss_slider.setRange(0, 50)
        miss_slider.setValue(int(param.get("miss_rate", 0.12) * 100))
        miss_slider.valueChanged.connect(lambda v: self.set_param(game_key, "miss_rate", v / 100))
        aim_layout.addWidget(miss_slider, 1, 1)

        advanced.addItem(aim_page, "ç„å‡†è®¾ç½®")

        # é€è§†è®¾ç½®
        esp_page = QWidget()
        esp_layout = QGridLayout(esp_page)
        esp_layout.addWidget(QLabel("ESPé¢œè‰²:"), 0, 0)
        color_btn = QPushButton("ç‚¹å‡»æ‹¾å–é¢œè‰²")
        color_btn.setStyleSheet(f"background-color: {param.get('esp_color', '#FF6464')}; min-height: 40px; border-radius: 10px;")
        color_btn.clicked.connect(lambda: self.choose_esp_color(game_key, color_btn))
        esp_layout.addWidget(color_btn, 0, 1)
        advanced.addItem(esp_page, "é€è§†è®¾ç½®")

        # å‹æªè®¾ç½®
        recoil_page = QWidget()
        recoil_layout = QGridLayout(recoil_page)
        curve_editor = CurveEditor()
        curve_editor.set_curve(param.get("recoil_curve", [0.0] * 30))
        curve_editor.save_callback = lambda curve: self.set_param(game_key, "recoil_curve", curve)
        recoil_layout.addWidget(curve_editor, 0, 0)
        advanced.addItem(recoil_page, "å‹æªè®¾ç½®")

        self.scroll_layout.addWidget(advanced)
        self.scroll_layout.addStretch()

    def choose_esp_color(self, game_key, btn):
        color = QColorDialog.getColor(QColor(param.get("esp_color", "#FF6464")))
        if color.isValid():
            hex_color = color.name()
            self.set_# src/ui/radar.py
# 2025å¹´ç»ˆæå¢å¼ºé›·è¾¾çª—ï¼ˆé€è§†ESP + è·ç¦» + è¡€æ¡ + éª¨éª¼çº¿ï¼‰

from PyQt5.QtWidgets import QDialog, QVBoxLayout
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QPainter, QColor, QPen, QBrush, QFont

from src.core.yolo_ai import visual_core
from src.core.screenshot import game_capture
from src.config.config import load_config

import math

class RadarWindow(QDialog):
    """
    å¢å¼ºé›·è¾¾çª—ï¼ˆåŒæ—¶ä½œä¸ºé€è§†ESPå åŠ çª—ï¼‰
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("å®‰é™AI - å¢å¼ºé›·è¾¾ï¼ˆé€è§†ESPï¼‰")
        self.setFixedSize(500, 500)
        self.setWindowFlags(Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint | Qt.Tool)
        self.setAttribute(Qt.WA_TranslucentBackground)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        self.radar_widget = EnhancedRadarWidget(self)
        layout.addWidget(self.radar_widget)
        self.setLayout(layout)

        # å®æ—¶æ›´æ–°
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.radar_widget.update_scene)
        self.timer.start(30)  # ~33FPSï¼Œæµç•…ä¸å¡

class EnhancedRadarWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.targets = []
        self.config = load_config()

    def update_scene(self):
        img = game_capture.capture()
        if img is not None:
            self.targets = visual_core.infer(img, conf=0.35, classes=[0])
        self.update()

    def paintEvent(self, event):
        qp = QPainter(self)
        qp.setRenderHint(QPainter.Antialiasing)

        w, h = self.width(), self.height()
        cx, cy = w // 2, h // 2
        radius = min(cx, cy) - 30

        # èƒŒæ™¯åŠé€æ˜åœ†
        qp.setBrush(QBrush(QColor(20, 30, 50, 200)))
        qp.setPen(QPen(QColor(100, 200, 255, 180), 3))
        qp.drawEllipse(cx - radius, cy - radius, radius * 2, radius * 2)

        # ç½‘æ ¼
        qp.setPen(QPen(QColor(60, 120, 180, 100), 1, Qt.DashLine))
        for i in range(1, 5):
            r = radius * i // 5
            qp.drawEllipse(cx - r, cy - r, r * 2, r * 2)

        # è‡ªå·±ï¼ˆä¸­å¿ƒï¼‰
        qp.setBrush(QBrush(QColor(0, 255, 100)))
        qp.setPen(QPen(QColor(0, 200, 80), 3))
        qp.drawEllipse(cx - 15, cy - 15, 30, 30)

        # æœå‘ç®­å¤´ï¼ˆæ¨¡æ‹Ÿç©å®¶è§†è§’ï¼‰
        qp.setBrush(QBrush(QColor(0, 180, 255)))
        qp.setPen(QPen(QColor(0, 140, 255), 4))
        qp.drawLine(cx, cy, cx, cy - radius + 20)

        if not self.targets:
            qp.setPen(QColor(200, 200, 200))
            qp.setFont(QFont("Microsoft YaHei", 12))
            qp.drawText(self.rect(), Qt.AlignCenter, "æ— ç›®æ ‡")
            return

        # ESPé¢œè‰²ï¼ˆä»é…ç½®è¯»å–ï¼‰
        esp_color = QColor(self.config.get("game_params", {}).get("CF", {}).get("esp_color", "#FF6464"))

        for target in self.targets:
            if "keypoints" not in target or "box" not in target:
                continue

            box = target["box"]
            kps = target["keypoints"]

            # è®¡ç®—æ•Œäººä¸­å¿ƒç›¸å¯¹ä½ç½®ï¼ˆç”¨äºé›·è¾¾ç‚¹ï¼‰
            box_center_x = (box[0] + box[2]) / 2
            box_center_y = (box[1] + box[3]) / 2
            rel_x = (box_center_x - w / 2) / radius
            rel_y = (box_center_y - h / 2) / radius
            distance = math.hypot(rel_x, rel_y) * 100  # æ¨¡æ‹Ÿè·ç¦»

            ex = cx + rel_x * radius * 0.9
            ey = cy + rel_y * radius * 0.9

            # é›·è¾¾ç‚¹
            qp.setBrush(QBrush(QColor(255, 60, 60)))
            qp.setPen(QPen(QColor(255, 0, 0), 2))
            qp.drawEllipse(int(ex - 10), int(ey - 10), 20, 20)

            # åå­— + è·ç¦»
            name = target.get("name", "æ•Œäºº")
            qp.setPen(QColor(255, 255, 255))
            qp.setFont(QFont("Microsoft YaHei", 9))
            qp.drawText(int(ex + 15), int(ey), f"{name} {int(distance)}m")

            # æ¨¡æ‹Ÿè¡€æ¡
            hp = random.randint(30, 100)  # æ¨¡æ‹Ÿè¡€é‡
            bar_width = 60
            bar_height = 8
            qp.setBrush(QBrush(QColor(100, 100, 100)))
            qp.drawRect(int(ex - bar_width//2), int(ey - 25), bar_width, bar_height)
            qp.setBrush(QBrush(QColor(0, 255, 0) if hp > 50 else QColor(255, 200, 0) if hp > 30 else QColor(255, 0, 0)))
            qp.drawRect(int(ex - bar_width//2), int(ey - 25), int(bar_width * hp / 100), bar_height)

            # éª¨éª¼çº¿ï¼ˆCOCOæ ‡å‡†å…³é”®è¿æ¥ï¼‰
            connections = [
                (0, 1), (1, 2), (0, 3), (3, 4),  # å¤´
                (5, 6), (5, 7), (7, 9), (6, 8), (8, 10),  # ä¸Šèº«æ‰‹è‡‚
                (5, 11), (6, 12), (11, 13), (12, 14)  # ä¸‹èº«è…¿
            ]
            qp.setPen(QPen(esp_color, 3))
            for a, b in connections:
                if a < len(kps) and b < len(kps):
                    ax, ay = kps[a]
                    bx, by = kps[b]
                    if ax > 0 and ay > 0 and bx > 0 and by > 0:
                        # æŠ•å½±åˆ°é›·è¾¾ç›¸å¯¹ä½ç½®ï¼ˆç®€åŒ–ï¼‰
                        proj_ax = cx + (ax - w/2) / radius * radius * 0.8
                        proj_ay = cy + (ay - h/2) / radius * radius * 0.8
                        proj_bx = cx + (bx - w/2) / radius * radius# ================== src/ui/stats.py ==================
from PyQt5.QtWidgets import QWidget, QDialog, QVBoxLayout, QLabel
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QPainter, QColor, QPen, QFont
import random
import math

class StatsWindow(QDialog):
    """
    ä»Šæ—¥å‡»æ€/KD/æœ€è¿œç‹™è·ç­‰æ›²çº¿å›¾ç»Ÿè®¡å°çª—
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("ä»Šæ—¥æˆ˜ç»©ç»Ÿè®¡")
        self.setFixedSize(380, 340)
        layout = QVBoxLayout()
        layout.addWidget(QLabel("ä»Šæ—¥å‡»æ€/çˆ†å¤´/æœ€è¿œç‹™å‡»ç­‰æ›²çº¿ï¼ˆä»…Demoï¼‰"))
        self.stats_view = StatsCurveWidget(self)
        layout.addWidget(self.stats_view)
        self.setLayout(layout)
        self._timer = QTimer(self)
        self._timer.timeout.connect(self.stats_view.update_data)
        self._timer.start(2000)  # æ¯2ç§’æ¨¡æ‹Ÿæ•°æ®åˆ·æ–°

class StatsCurveWidget(QWidget):
    """
    æ›²çº¿å›¾åŠæ•°æ®æ¨¡æ‹Ÿ
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.data = {
            "kill": [random.randint(0, 10) for _ in range(12)],
            "kd": [round(random.uniform(0.5, 3.0), 2) for _ in range(12)],
            "snipe": [random.randint(20, 300) for _ in range(12)]
        }
        self.ptr = 12

    def update_data(self):
        # æ¨¡æ‹Ÿæ–°ä¸€è½®æˆç»©
        if len(self.data["kill"]) >= 30:
            for k in self.data: self.data[k] = self.data[k][1:]
        self.data["kill"].append(random.randint(0, 18))
        self.data["kd"].append(round(random.uniform(0.7, 4.3), 2))
        self.data["snipe"].append(random.randint(33, 366))
        self.ptr += 1
        self.update()

    def paintEvent(self, event):
        qp = QPainter(self)
        qp.setRenderHint(QPainter.Antialiasing)
        w, h = self.width(), self.height()
        margin = 40
        rect_w = w - margin * 2
        rect_h = h - margin * 2
        # åæ ‡è½´
        qp.setPen(QPen(QColor(120, 120, 120), 2))
        qp.drawLine(margin, margin, margin, h-margin)
        qp.drawLine(margin, h-margin, w-margin, h-margin)
        # ç»˜åˆ¶æ¯æ¡æ›²çº¿
        self._draw_curve(qp, self.data["kill"], margin, h, rect_w, rect_h,
                         QColor(255,100,100), "å‡»æ€æ•°/å±€")
        self._draw_curve(qp, self.data["kd"], margin, h, rect_w, rect_h,
                         QColor(80,180,255), "K/D")
        self._draw_curve(qp, [x/20.0 for x in self.data["snipe"]], margin, h, rect_w, rect_h,
                         QColor(220,100,255), "æœ€è¿œç‹™å‡»/20m")
        # æ ‡è®°å·¦ä¸Šè§’
        qp.setFont(QFont("å¾®è½¯é›…é»‘", 9))
        qp.setPen(QColor(90, 90, 90))
        qp.drawText(margin+8, margin-10, f"å±€æ•°:{len(self.data['kill'])}")

    def _draw_curve(self, qp, datalist, margin, h, rect_w, rect_h, color, label):
        N = len(datalist)
        if N < 2: return
        step_x = rect_w // (N-1) if N>1 else rect_w
        points = []
        maxy = max(max(datalist), 1)
        miny = min(min(datalist), 0)
        scale = rect_h / (maxy - miny + 1e-2)
        # ç”»æ›²çº¿
        for i, v in enumerate(datalist):
            x = margin + i * step_x
            y = h - margin - (v - miny) * scale
            points.append((x, y))
        qp.setPen(QPen(color, 2))
        for i in range(N-1):
            qp.drawLine(int(points[i][0]), int(points[i][1]), int(points[i+1][0]), int(points[i+1][1]))
        # æœ€å³ä¸‹è§’æ ‡è®°
        qp.setPen(color)
        qp.setFont(QFont("å¾®è½¯é›…é»‘", 10, QFont.Bold))
        qp.drawText(int(points[-1][0]-36), int(points[-1][1]-13), label)

# ================== src/ui/stats.py å®Œï¼Œä¸‹ä¸€ä¸ªæ¨èæ¨¡å—å…¥å£ src/config/config.pyï¼ˆé…ç½®å­˜å–ä¸åŠ å¯†ï¼‰ ==================

# æ‹¼æ¥è¯´æ˜ï¼šæˆ˜ç»©ç»Ÿè®¡çª—ä»£ç å®ç°å®Œæ¯•ã€‚
# ä¸‹ä¸€æ­¥åœ¨ src/config/ ç›®å½•ä¸‹æ–°å»º config.pyï¼Œç­‰å¾…é…ç½®è¯»å†™æ¨¡å—ã€‚# src/ui/theme.py
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QLabel, QHBoxLayout, QComboBox, QPushButton, QLineEdit, QMessageBox, QSpacerItem, QSizePolicy
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QPalette, QColor
import json
import os
from src.tools.resource_path import resource_path
from appdirs import user_config_dir

class ThemeManager:
    """
    å…¨å±€ä¸»é¢˜ç®¡ç†ï¼Œæ”¯æŒå¤šçš®è‚¤ã€å®æ—¶åº”ç”¨ã€ç”¨æˆ·ç›®å½•æŒä¹…åŒ–
    """
    _builtin_themes = {
        "default": {
            "name": "æç®€ç™½",
            "palette": {
                "base": "#F9FAFC",
                "window": "#FFFFFF",
                "text": "#222",
                "button": "#F3F5F7",
                "highlight": "#4488FF",
                "highlightedText": "#fff"
            }
        },
        "dark": {
            "name": "æš—è‰²ç§‘æŠ€",
            "palette": {
                "base": "#23283C",
                "window": "#181B2C",
                "text": "#F2F2F2",
                "button": "#22264B",
                "highlight": "#37D1F2",
                "highlightedText": "#181B2C"
            }
        },
        "transparent_blue": {
            "name": "è“å…‰é€æ˜",
            "palette": {
                "base": "#1e293bCC",
                "window": "#151b29CC",
                "text": "#DEE6FC",
                "button": "#223059A0",
                "highlight": "#54CFFD",
                "highlightedText": "#222"
            }
        },
        "gray": {
            "name": "æç®€äº®ç°",
            "palette": {
                "base": "#F2F2F8",
                "window": "#FAFAFA",
                "text": "#121212",
                "button": "#EEE",
                "highlight": "#7090DA",
                "highlightedText": "#FFF"
            }
        },
        "night": {
            "name": "æ·±é‚ƒæ˜Ÿç©º",
            "palette": {
                "base": "#181A25",
                "window": "#171825",
                "text": "#F0EFFF",
                "button": "#23254D",
                "highlight": "#B356E8",
                "highlightedText": "#fff"
            }
        },
        "neon": {
            "name": "è§å…‰ç»¿é»‘",
            "palette": {
                "base": "#131F15",
                "window": "#151E13",
                "text": "#ABFF93",
                "button": "#192923",
                "highlight": "#45FFB7",
                "highlightedText": "#151E13"
            }
        },
        "purple": {
            "name": "ç‚«å…‰ç´«é»‘",
            "palette": {
                "base": "#221B4A",
                "window": "#171627",
                "text": "#F3EFFF",
                "button": "#2D2257",
                "highlight": "#D15EDB",
                "highlightedText": "#fff"
            }
        }
    }

    # ä½¿ç”¨ç”¨æˆ·ç›®å½•æŒä¹…åŒ–
    CONFIG_DIR = user_config_dir("AnjingAI")
    CONFIG_FILE = os.path.join(CONFIG_DIR, "theme_config.json")

    def __init__(self):
        self.current_theme = "default"
        self.user_custom = {}
        os.makedirs(self.CONFIG_DIR, exist_ok=True)
        self._load_config()

    def get_theme_list(self):
        base = list(self._builtin_themes.keys())
        if self.user_custom:
            base.extend([f"user_{k}" for k in self.user_custom.keys()])
        return base

    def get_theme_meta(self, theme_key):
        if theme_key.startswith("user_"):
            name = theme_key[5:]
            return self.user_custom.get(name, self._builtin_themes["default"])
        return self._builtin_themes.get(theme_key, self._builtin_themes["default"])

    def get_stylesheet(self, theme_key=None):
        key = theme_key or self.current_theme
        palette = self.get_theme_meta(key)["palette"]
        base = palette["base"]
        window = palette["window"]
        text = palette["text"]
        button = palette["button"]
        highlight = palette["highlight"]
        highlighted_text = palette["highlightedText"]

        return f"""
        QWidget {{
            background: {window};
            color: {text};
        }}
        QPushButton, QComboBox, QLineEdit, QTextEdit, QCheckBox {{
            background: {button};
            border: 1px solid {highlight}70;
            color: {text};
            border-radius: 4px;
            padding: 5px;
        }}
        QPushButton:hover {{
            background: {highlight}33;
        }}
        QTabWidget::pane {{
            border: 1px solid {highlight};
            border-radius: 8px;
        }}
        QTabBar::tab:selected {{
            background: {highlight};
            color: {highlighted_text};
        }}
        QStatusBar {{
            background: {window};
            color: {text};
        }}
        QToolTip {{
            background: {highlight}DD;
            color: {highlighted_text};
            border-radius: 4px;
            padding: 6px;
        }}
        """

    def apply_theme(self, app):
        """å…¨å±€åº”ç”¨ä¸»é¢˜"""
        app.setStyleSheet(self.get_stylesheet())

    def set_theme(self, theme_key: str, app=None):
        self.current_theme = theme_keyself.cb.setCurrentIndex(0)

        self.cb.currentIndexChanged.connect(self._on_theme_changed)
        layout.addWidget(self.cb)

        layout.addSpacerItem(QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding))

        # éšè—çš„ç®¡ç†å‘˜å¯†ç è¾“å…¥
        pwd_layout = QHBoxLayout()
        pwd_label = QLabel("è®¿é—®ç ï¼ˆé«˜çº§åŠŸèƒ½ï¼‰ï¼š")
        pwd_label.setStyleSheet("color:#888;font-size:12px;")
        pwd_layout.addWidget(pwd_label)

        self.pw_edit = QLineEdit()
        self.pw_edit.setEchoMode(QLineEdit.Password)
        self.pw_edit.setPlaceholderText("å¯é€‰ï¼Œæ™®é€šæ¢è‚¤æ— éœ€è¾“å…¥")
        pwd_layout.addWidget(self.pw_edit)
        layout.addLayout(pwd_layout)

        # æŒ‰é’®
        btn_layout = QHBoxLayout()
        btn_ok = QPushButton("åº”ç”¨ä¸»é¢˜")
        btn_cancel = QPushButton("å–æ¶ˆ")
        btn_ok.clicked.connect(self._apply_and_accept)
        btn_cancel.clicked.connect(self.reject)
        btn_layout.addStretch()
        btn_layout.addWidget(btn_ok)
        btn_layout.addWidget(btn_cancel)
        layout.addLayout(btn_layout)

        tip = QLabel("è¾“å¯¹è®¿é—®ç å¯è§£é”é«˜çº§æ¨¡å—ï¼Œå¸¸ç”¨ä¸éœ€è¾“å…¥ï¼Œåªç®¡åˆ‡ä¸»é¢˜å³å¯ã€‚")
        tip.setStyleSheet("color:#777;font-size:12px;")
        tip.setAlignment(Qt.AlignCenter)
        layout.addWidget(tip)

        self.setLayout(layout)

    def _on_theme_changed(self, idx):
        if 0 <= idx < len(self.theme_keys):
            key = self.theme_keys[idx]
            # å®æ—¶é¢„è§ˆå…¨å±€
            if self.parent() and hasattr(self.parent(), 'parent') and self.parent().parent():
                app = self.parent().parent()  # MainWindow -> SafeApp
                self.theme_manager.set_theme(key, app)

    def _preview_current(self):
        self._on_theme_changed(self.cb.currentIndex())

    def _apply_and_accept(self):
        idx = self.cb.currentIndex()
        if 0 <= idx < len(self.theme_keys):
            key = self.theme_keys[idx]
            self.theme_manager.set_theme(key)
            self.admin_password = self.pw_edit.text().strip()
            self.accept()

    def get_admin_password(self):
        return self.admin_passworddef __init__(self):
        super().__init__(name="NZ")

class YJHelper(BaseGameHelper):
    def __init__(self):
        super().__init__(name="YJ")

class PUBGHelper(BaseGameHelper):
    def __init__(self):
        super().__init__(name="PUBG")

# ç»Ÿä¸€æœåŠ¡
class CheatService:
    def __init__(self):
        self.helpers = {
            "CF": CFHelper(),
            "CFHD": CFHDHelper(),
            "DELTA": DeltaHelper(),
            "VAL": ValorantHelper(),
            "CSGO": CSGOHelper(),
            "PEACE": PeaceEliteHelper(),
            "NZ": NZHelper(),
            "YJ": YJHelper(),
            "PUBG": PUBGHelper(),
        }
def start_cheat(self, game_key: str, game_param: dict):
        if game_key.upper() in self.helpers:
            self.helpers[game_key.upper()].start(params=game_param)

    def stop_cheat(self, game_key: str):
        if game_key.upper() in self.helpers:
            self.helpers[game_key.upper()].stop()

    def stop_all(self):
        for helper in self.helpers.values():
            helper.stop()

cheat_service = CheatService()